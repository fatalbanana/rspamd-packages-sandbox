name: Publish package (Debian)

on:
  workflow_call:
    inputs:
      names:
        required: true
        type: string
        description: 'Comma-separated target distro names (e.g., debian-trixie,debian-bookworm)'
      nightly:
        required: false
        type: string
        description: 'Set to any value to enable nightly (unstable) publish logic.'

concurrency:
  group: debian-publishing-${{ inputs.nightly && 'nightly' || 'stable' }}
  cancel-in-progress: false

jobs:
  publish:
    name: 'publish (debian)'
    runs-on: 'ubuntu-24.04'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'

      - name: Build aptly from source
        run: |
          # Get latest release tag
          APTLY_VERSION=$(curl -s https://api.github.com/repos/aptly-dev/aptly/releases/latest | grep '"tag_name"' | cut -d'"' -f4)
          echo "Installing aptly ${APTLY_VERSION}"
          
          git clone --depth 1 --branch "${APTLY_VERSION}" https://github.com/aptly-dev/aptly.git /tmp/aptly
          cd /tmp/aptly
          make install
          aptly version

      - name: Prepare GPG
        shell: bash
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GPG_KEY_ID: ${{ vars.GPG_KEY_ID }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.gnupg"
          chmod 700 "$HOME/.gnupg"
          # Import private key, handling raw, escaped \n, or base64-encoded formats
          if [[ -z "${GPG_PRIVATE_KEY:-}" ]]; then
            echo "GPG_PRIVATE_KEY is empty or not set" >&2
            exit 1
          fi
          KEY_TMP="$RUNNER_TEMP/privkey.asc"
          rm -f "$KEY_TMP"
          # Try direct content first
          printf '%s\n' "$GPG_PRIVATE_KEY" > "$KEY_TMP"
          if ! grep -q "BEGIN PGP" "$KEY_TMP"; then
            # Try un-escaping literal \n sequences
            printf '%b' "${GPG_PRIVATE_KEY//\\n/$'\n'}" > "$KEY_TMP"
          fi
          if ! grep -q "BEGIN PGP" "$KEY_TMP"; then
            # Try base64 decoding to ASCII-armored key
            echo "$GPG_PRIVATE_KEY" | base64 -d > "$KEY_TMP" 2>/dev/null || true
          fi
          if ! grep -q "BEGIN PGP" "$KEY_TMP"; then
            echo "Failed to reconstruct OpenPGP private key from secret" >&2
            exit 1
          fi
          gpg --batch --import "$KEY_TMP"
          rm -f "$KEY_TMP"
          KEY_FPR=${GPG_KEY_ID}
          if [[ -z "${KEY_FPR}" ]]; then
            KEY_FPR=$(gpg --list-secret-keys --with-colons | awk -F: '/^fpr:/ {print $10; exit}')
          fi
          echo "KEY_FPR=${KEY_FPR}" >> "$GITHUB_ENV"
          # Configure loopback pinentry for non-interactive signing
          {
            echo "use-agent"
            echo "pinentry-mode loopback"
          } >> "$HOME/.gnupg/gpg.conf"
          echo "allow-loopback-pinentry" >> "$HOME/.gnupg/gpg-agent.conf"
          # Restart agent to apply settings and prime with passphrase
          gpg-connect-agent reloadagent /bye
          echo "${GPG_PASSPHRASE}" | gpg --pinentry-mode loopback --passphrase-fd 0 -u "$KEY_FPR" --batch --sign -o /dev/null /dev/null

      - name: Download all debian package artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: packages-debian-*
          path: packages
          merge-multiple: true

      - name: Download all ubuntu package artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: packages-ubuntu-*
          path: packages
          merge-multiple: true


      - name: Build and publish APT repository with aptly
        env:
          NIGHTLY: ${{ inputs.nightly }}
          UPLOAD_HOST: ${{ secrets.UPLOAD_HOST }}
          UPLOAD_SUFFIX: ${{ vars.UPLOAD_SUFFIX || 'rspamd.com/dist/' }}
          TARGET_DEB_STABLE: ${{ vars.TARGET_DEB_STABLE || 'apt-stable' }}
          TARGET_DEB_UNSTABLE: ${{ vars.TARGET_DEB_UNSTABLE || 'apt' }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          KEEP_BUILDS_STABLE: ${{ vars.KEEP_BUILDS_STABLE || '10' }}
          KEEP_BUILDS_NIGHTLY: ${{ vars.KEEP_BUILDS_NIGHTLY || '10' }}
          UPLOAD_HOST_KNOWN_HOSTS: ${{ vars.UPLOAD_HOST_KNOWN_HOSTS }}
          DIST_NAMES: ${{ inputs.names }}
          SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
          APT_REPO_URL: ${{ vars.APT_REPO_URL_STABLE || 'https://rspamd.com/apt-stable/' }}
        run: |
          set -x
          set -euo pipefail
          
          # Determine target path and repo URL
          if [[ -n "${NIGHTLY:-}" ]]; then
            TARGET_PATH="$TARGET_DEB_UNSTABLE"
            SSH_KEY='${{ secrets.SSH_KEY_DEB_UNSTABLE }}'
            APT_URL="${{ vars.APT_REPO_URL_UNSTABLE || 'https://rspamd.com/apt/' }}"
            KEEP_BUILDS="${KEEP_BUILDS_NIGHTLY}"
          else
            TARGET_PATH="$TARGET_DEB_STABLE"
            SSH_KEY='${{ secrets.SSH_KEY_DEB_STABLE }}'
            APT_URL="${APT_REPO_URL}"
            KEEP_BUILDS="${KEEP_BUILDS_STABLE}"
          fi
          
          # Setup SSH
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          echo "$UPLOAD_HOST_KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          
          # Configure aptly
          APTLY_ROOT="$HOME/.aptly"
          mkdir -p "$APTLY_ROOT"
          cat > ~/.aptly.conf << 'EOF'
          {
            "downloadConcurrency": 4,
            "architectures": [],
            "dependencyFollowSuggests": false,
            "dependencyFollowRecommends": false,
            "gpgDisableSign": false,
            "gpgDisableVerify": false,
            "downloadSourcePackages": false,
            "skipLegacyPool": true,
            "ppaDistributorID": "rspamd",
            "skipContentsPublishing": false
          }
          EOF
          
          # Mirror existing published repositories from public URL
          # This allows us to work with existing packages without maintaining database state
          IFS=',' read -ra DIST_LIST <<< "$DIST_NAMES"
          for d in "${DIST_LIST[@]}"; do
            codename="${d/ubuntu-/}"
            codename="${codename/debian-/}"
            MIRROR_NAME="rspamd-${codename}-mirror"
            REPO_NAME="rspamd-${codename}"
            
            # Try to create mirror from existing published repo
            echo "Attempting to mirror existing repository for ${codename}..."
            if curl -sf "${APT_URL}dists/${codename}/Release" >/dev/null 2>&1; then
              aptly mirror create -ignore-signatures "$MIRROR_NAME" "$APT_URL" "$codename" main || true
              aptly mirror update -ignore-signatures "$MIRROR_NAME" || true
              
              # Create local repo and import from mirror
              if ! aptly repo show "$REPO_NAME" >/dev/null 2>&1; then
                aptly repo create -distribution="$codename" -component=main "$REPO_NAME"
              fi
              aptly repo import "$MIRROR_NAME" "$REPO_NAME" 'Name' || true
            else
              echo "No existing published repo found for ${codename}, starting fresh"
              if ! aptly repo show "$REPO_NAME" >/dev/null 2>&1; then
                aptly repo create -distribution="$codename" -component=main "$REPO_NAME"
              fi
            fi
          done
          
          # Process each distribution
          IFS=',' read -ra DIST_LIST <<< "$DIST_NAMES"
          for d in "${DIST_LIST[@]}"; do
            codename="${d/ubuntu-/}"
            codename="${codename/debian-/}"
            REPO_NAME="rspamd-${codename}"
            
            # Create repo if it doesn't exist
            if ! aptly repo show "$REPO_NAME" >/dev/null 2>&1; then
              echo "Creating repository: $REPO_NAME"
              aptly repo create -distribution="$codename" -component=main "$REPO_NAME"
            fi
            
            # Check retention BEFORE adding new packages
            # For each package type, see if we already have KEEP_BUILDS versions
            for pkg_base in rspamd rspamd-asan rspamd-dbg rspamd-asan-dbg; do
              # Get current count of versions for this package
              count=$(aptly repo search "$REPO_NAME" "Name (= $pkg_base)" 2>/dev/null | wc -l || echo "0")
              
              if [ "$count" -ge "$KEEP_BUILDS" ]; then
                # Need to remove oldest version(s) to make room
                versions=$(aptly repo search "$REPO_NAME" "Name (= $pkg_base)" 2>/dev/null | \
                  grep "^${pkg_base}_" | awk '{print $1}' | sed "s/${pkg_base}_//" | sort -V || true)
                
                # Remove oldest version (first in sorted list)
                echo "$versions" | head -n $((count - KEEP_BUILDS + 1)) | while read old_version; do
                  echo "Removing old version to make room: ${pkg_base} ${old_version}"
                  aptly repo remove "$REPO_NAME" "Name (= $pkg_base), Version (= $old_version)" || true
                done
              fi
            done
            
            # Now add new packages
            shopt -s nullglob
            for deb_pkg in "$GITHUB_WORKSPACE/packages/${d}"/*.deb; do
              echo "Adding package: $deb_pkg"
              aptly repo add -force-replace "$REPO_NAME" "$deb_pkg"
            done
            
            # Publish or update
            if aptly publish list 2>/dev/null | grep -q "$codename"; then
              echo "Updating published repository: $codename"
              aptly publish update -batch -passphrase="$GPG_PASSPHRASE" "$codename"
            else
              echo "Publishing repository: $codename"
              aptly publish repo -batch -passphrase="$GPG_PASSPHRASE" \
                -distribution="$codename" \
                -origin="Rspamd" \
                -label="Rspamd" \
                -suite="" \
                "$REPO_NAME"
            fi
          done
          
          # Export public key
          mkdir -p "$APTLY_ROOT/public"
          gpg --batch --armor --output "$APTLY_ROOT/public/rspamd.asc" --export "$KEY_FPR"
          
          # Upload published repos
          rsync -e "ssh -l $SSH_USERNAME -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes" -rlptDv --delete \
            "$APTLY_ROOT/public/" "${UPLOAD_HOST}:${UPLOAD_SUFFIX}${TARGET_PATH}/"
      
