name: Publish package (RPM)

on:
  workflow_call:
    inputs:
      name:
        required: true
        type: string
        description: 'The target OS/distro name to publish (e.g., centos-9)'
      nightly:
        required: false
        type: string
        description: 'Set to any value to enable nightly (unstable) publish logic.'

concurrency:
  group: rpm-publishing-${{ inputs.name }}-${{ inputs.nightly && 'nightly' || 'stable' }}
  cancel-in-progress: false

jobs:
  publish:
    name: 'publish (${{ inputs.name }})'
    runs-on: 'ubuntu-24.04'

    steps:
      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y rpm createrepo-c gnupg rsync expect

      - name: Prepare GPG
        shell: bash
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GPG_KEY_ID: ${{ vars.GPG_KEY_ID }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.gnupg"
          chmod 700 "$HOME/.gnupg"
          # Import private key, handling raw, escaped \n, or base64-encoded formats
          if [[ -z "${GPG_PRIVATE_KEY:-}" ]]; then
            echo "GPG_PRIVATE_KEY is empty or not set" >&2
            exit 1
          fi
          KEY_TMP="$RUNNER_TEMP/privkey.asc"
          rm -f "$KEY_TMP"
          # Try direct content first
          printf '%s\n' "$GPG_PRIVATE_KEY" > "$KEY_TMP"
          if ! grep -q "BEGIN PGP" "$KEY_TMP"; then
            # Try un-escaping literal \n sequences
            printf '%b' "${GPG_PRIVATE_KEY//\\n/$'\n'}" > "$KEY_TMP"
          fi
          if ! grep -q "BEGIN PGP" "$KEY_TMP"; then
            # Try base64 decoding to ASCII-armored key
            echo "$GPG_PRIVATE_KEY" | base64 -d > "$KEY_TMP" 2>/dev/null || true
          fi
          if ! grep -q "BEGIN PGP" "$KEY_TMP"; then
            echo "Failed to reconstruct OpenPGP private key from secret" >&2
            exit 1
          fi
          gpg --batch --import "$KEY_TMP"
          rm -f "$KEY_TMP"
          KEY_FPR=${GPG_KEY_ID}
          if [[ -z "${KEY_FPR}" ]]; then
            KEY_FPR=$(gpg --list-secret-keys --with-colons | awk -F: '/^fpr:/ {print $10; exit}')
          fi
          echo "KEY_FPR=${KEY_FPR}" >> "$GITHUB_ENV"
          # Ensure loopback pinentry is allowed for non-interactive gpg
          {
            echo "use-agent"
            echo "pinentry-mode loopback"
          } >> "$HOME/.gnupg/gpg.conf"
          echo "allow-loopback-pinentry" >> "$HOME/.gnupg/gpg-agent.conf"
          {
            echo "%_signature gpg"
            echo "%_gpg_name ${KEY_FPR}"
            echo "%_gpg_path $HOME/.gnupg"
            echo "%__gpg /usr/bin/gpg"
            echo "%__gpg_sign_cmd %{__gpg} gpg --batch --yes --pinentry-mode loopback --detach-sign --local-user ${KEY_FPR} --output %{__signature_filename} %{__plaintext_filename}"
          } >> "$HOME/.rpmmacros"

          # Restart agent to apply settings and prime with passphrase
          gpg-connect-agent reloadagent /bye
          echo "${GPG_PASSPHRASE}" | gpg --pinentry-mode loopback --passphrase-fd 0 -u "$KEY_FPR" --batch --sign -o /dev/null /dev/null

      - name: Download all package artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: packages-centos-*
          path: packages
          merge-multiple: true

      - name: Inspect
        run: ls -lR packages

      - name: Prepare repo and sign RPMs
        shell: bash
        env:
          KEEP_BUILDS_STABLE: ${{ vars.KEEP_BUILDS_STABLE || '10' }}
          KEEP_BUILDS_NIGHTLY: ${{ vars.KEEP_BUILDS_NIGHTLY || '10' }}
          NIGHTLY: ${{ inputs.nightly }}
          TARGET_RPM_STABLE: ${{ vars.TARGET_RPM_STABLE || 'rpm-stable' }}
          TARGET_RPM_UNSTABLE: ${{ vars.TARGET_RPM_UNSTABLE || 'rpm' }}
          SKIP_MIRROR_RPM: ${{ vars.SKIP_MIRROR_RPM }}
          UPLOAD_HOST: ${{ secrets.UPLOAD_HOST }}
          UPLOAD_HOST_KNOWN_HOSTS: ${{ vars.UPLOAD_HOST_KNOWN_HOSTS }}
          UPLOAD_SUFFIX: ${{ vars.UPLOAD_SUFFIX || 'rspamd.com/dist/' }}
        run: |
          set -x
          set -euo pipefail
          DIST="${{ inputs.name }}"
          
          # Determine keep builds based on nightly/stable
          if [[ -n "${NIGHTLY:-}" ]]; then
            KEEP_BUILDS="${KEEP_BUILDS_NIGHTLY}"
          else
            KEEP_BUILDS="${KEEP_BUILDS_STABLE}"
          fi
          REPO_DIR="$GITHUB_WORKSPACE/rpm/$DIST"
          mkdir -p "$REPO_DIR/x86_64" "$REPO_DIR/aarch64"

          # Setup SSH credentials
          if [[ -n "${NIGHTLY:-}" ]]; then
            TARGET_PATH="$TARGET_RPM_UNSTABLE/${{ inputs.name }}"
            RSYNC_KEY='${{ secrets.SSH_KEY_RPM_UNSTABLE }}'
          else
            TARGET_PATH="$TARGET_RPM_STABLE/${{ inputs.name }}"
            RSYNC_KEY='${{ secrets.SSH_KEY_RPM_STABLE }}'
          fi
          mkdir -p "$HOME/.ssh" && chmod 700 "$HOME/.ssh"
          KEYFILE="$HOME/.ssh/gh_publish_key"
          echo "$RSYNC_KEY" > "$KEYFILE"
          chmod 600 "$KEYFILE"
          echo "KEYFILE=${KEYFILE}" >> "$GITHUB_ENV"
          if [[ -z "${UPLOAD_HOST_KNOWN_HOSTS:-}" ]]; then
            echo "Missing UPLOAD_HOST_KNOWN_HOSTS GitHub variable" >&2
            exit 1
          fi
          printf '%s\n' "$UPLOAD_HOST_KNOWN_HOSTS" > "$HOME/.ssh/known_hosts"
          chmod 644 "$HOME/.ssh/known_hosts"
          
          # Mirror existing repository or start fresh
          if [[ -z "${SKIP_MIRROR_RPM:-}" ]]; then
            echo "Syncing existing repository content..."
            SSH_CMD="ssh -l ${{ secrets.SSH_USERNAME }} -i ${KEYFILE} -o UserKnownHostsFile=$HOME/.ssh/known_hosts -o StrictHostKeyChecking=yes"
            rsync -e "$SSH_CMD" -ru "${UPLOAD_HOST}:${UPLOAD_SUFFIX}${TARGET_PATH}/" "$REPO_DIR/"
          else
            echo "SKIP_MIRROR_RPM is set, starting with empty repository"
            mkdir -p "$REPO_DIR/x86_64" "$REPO_DIR/aarch64"
          fi

          # Copy built artifacts into arch dirs and record newly added files for signing
          # Skip if exact version already exists
          shopt -s nullglob
          COPIED_FILES=()
          for rpm in "$GITHUB_WORKSPACE/packages/$DIST/"*x86_64.rpm; do
            rpm_name=$(basename "$rpm")
            if [[ -f "$REPO_DIR/x86_64/$rpm_name" ]]; then
              echo "Package $rpm_name already exists in x86_64 repo, skipping"
              continue
            fi
            cp -f "$rpm" "$REPO_DIR/x86_64/"
            COPIED_FILES+=("$REPO_DIR/x86_64/$rpm_name")
          done
          for rpm in "$GITHUB_WORKSPACE/packages/$DIST/"*aarch64.rpm; do
            rpm_name=$(basename "$rpm")
            if [[ -f "$REPO_DIR/aarch64/$rpm_name" ]]; then
              echo "Package $rpm_name already exists in aarch64 repo, skipping"
              continue
            fi
            cp -f "$rpm" "$REPO_DIR/aarch64/"
            COPIED_FILES+=("$REPO_DIR/aarch64/$rpm_name")
          done

          # Sign only the newly added RPMs to avoid re-signing existing ones
          for file in "${COPIED_FILES[@]}"; do
            [[ -f "$file" ]] || continue
            rpm --addsign "$file"
          done

          # Retention: keep only the latest N builds per package group and remove the rest
          keep_count="${KEEP_BUILDS:-10}"
          if [[ "$keep_count" =~ ^[0-9]+$ ]] && (( keep_count > 0 )); then
            for arch in x86_64 aarch64; do
              # Map base_name to a string containing "BTIME EVR\n" lines
              declare -A base_name_builds_str=()
              while IFS= read -r -d '' file; do
                pkg_name=$(rpm -qp --qf '%{NAME}\n' "$file" 2>/dev/null || echo '')
                [[ -n "$pkg_name" ]] || continue
                base_name="${pkg_name%-debuginfo}"
                base_name="${base_name%-debugsource}"
                evr=$(rpm -qp --qf '%{EPOCHNUM}:%{VERSION}-%{RELEASE}\n' "$file" 2>/dev/null || echo '')
                [[ -n "$evr" ]] || continue
                btime=$(rpm -qp --qf '%{BUILDTIME}\n' "$file" 2>/dev/null || echo '0')
                base_name_builds_str["$base_name"]="${base_name_builds_str[$base_name]:-}$btime $evr\n"
              done < <(find "$REPO_DIR/$arch" -maxdepth 1 -type f -name '*.rpm' -print0)

              declare -A keep_map=()
              for base_name in "${!base_name_builds_str[@]}"; do
                # For each base_name, sort its builds by buildtime and keep top N EVRs
                mapfile -t sorted_evrs < <(echo -e "${base_name_builds_str[$base_name]}" | sort -k1,1nr -k2,2 | awk '{print $2}' | uniq)
                
                top_evrs=("${sorted_evrs[@]:0:$keep_count}")
                for evr in "${top_evrs[@]}"; do
                  keep_map["$base_name:$evr"]=1
                done
              done

              # Remove older RPMs
              while IFS= read -r -d '' file; do
                pkg_name=$(rpm -qp --qf '%{NAME}\n' "$file" 2>/dev/null || echo '')
                [[ -n "$pkg_name" ]] || continue
                base_name="${pkg_name%-debuginfo}"
                base_name="${base_name%-debugsource}"
                evr=$(rpm -qp --qf '%{EPOCHNUM}:%{VERSION}-%{RELEASE}\n' "$file" 2>/dev/null || echo '')
                [[ -n "$evr" ]] || continue
                key="$base_name:$evr"
                if [[ -z "${keep_map[$key]:-}" ]]; then
                  rm -f "$file"
                fi
              done < <(find "$REPO_DIR/$arch" -maxdepth 1 -type f -name '*.rpm' -print0)
            done
          fi

          # Create repo metadata and sign it for each arch present
          for arch in x86_64 aarch64; do
            if compgen -G "$REPO_DIR/$arch/*.rpm" > /dev/null; then
              (cd "$REPO_DIR/$arch" && createrepo_c --compress-type gz .)
              gpg --batch --yes --pinentry-mode loopback --default-key "$KEY_FPR" --detach-sign --armor "$REPO_DIR/$arch/repodata/repomd.xml"
            fi
          done

          # Write repo file for clients (avoid YAML/heredoc indentation pitfalls)
          if [[ -n "${NIGHTLY:-}" ]]; then
            {
              printf '%s\n' "[rspamd-experimental]"
              printf '%s\n' "name=Rspamd experimental repository"
              printf 'baseurl=http://rspamd.com/rpm/%s/$basearch\n' "$DIST"
              printf '%s\n' "enabled=1"
              printf '%s\n' "gpgcheck=1"
              printf '%s\n' "repo_gpgcheck=1"
              printf '%s\n' "gpgkey=http://rspamd.com/rpm/rspamd.asc"
            } > "$REPO_DIR/rspamd-experimental.repo"
          else
            {
              printf '%s\n' "[rspamd]"
              printf '%s\n' "name=Rspamd stable repository"
              printf 'baseurl=http://rspamd.com/rpm-stable/%s/$basearch\n' "$DIST"
              printf '%s\n' "enabled=1"
              printf '%s\n' "gpgcheck=1"
              printf '%s\n' "repo_gpgcheck=1"
              printf '%s\n' "gpgkey=http://rspamd.com/rpm/rspamd.asc"
            } > "$REPO_DIR/rspamd.repo"
          fi

          # Export public key for clients
          mkdir -p "$GITHUB_WORKSPACE/rpm"
          gpg --armor --output "$GITHUB_WORKSPACE/rpm/rspamd.asc" --export "$KEY_FPR"

      - name: Upload repo via rsync
        shell: bash
        env:
          NIGHTLY: ${{ inputs.nightly }}
          UPLOAD_HOST: ${{ secrets.UPLOAD_HOST }}
          UPLOAD_SUFFIX: ${{ vars.UPLOAD_SUFFIX || 'rspamd.com/dist/' }}
          TARGET_RPM_STABLE: ${{ vars.TARGET_RPM_STABLE || 'rpm-stable' }}
          TARGET_RPM_UNSTABLE: ${{ vars.TARGET_RPM_UNSTABLE || 'rpm' }}
          UPLOAD_HOST_KNOWN_HOSTS: ${{ vars.UPLOAD_HOST_KNOWN_HOSTS }}
        run: |
          set -euo pipefail
          if [[ -n "${NIGHTLY:-}" ]]; then
            TARGET_PATH="$TARGET_RPM_UNSTABLE/${{ inputs.name }}"
          else
            TARGET_PATH="$TARGET_RPM_STABLE/${{ inputs.name }}"
          fi
          RSYNC_ARGS="-ru --delete"
          rsync -e "ssh -l ${{ secrets.SSH_USERNAME }} -i ${KEYFILE} -o UserKnownHostsFile=$HOME/.ssh/known_hosts -o StrictHostKeyChecking=yes" $RSYNC_ARGS \
            "$GITHUB_WORKSPACE/rpm/${{ inputs.name }}/" "${UPLOAD_HOST}:${UPLOAD_SUFFIX}${TARGET_PATH}/"

      - name: Upload public key to rpm roots
        shell: bash
        env:
          TARGET_RPM_STABLE: ${{ vars.TARGET_RPM_STABLE || 'rpm-stable' }}
          TARGET_RPM_UNSTABLE: ${{ vars.TARGET_RPM_UNSTABLE || 'rpm' }}
          UPLOAD_HOST: ${{ secrets.UPLOAD_HOST }}
          UPLOAD_HOST_KNOWN_HOSTS: ${{ vars.UPLOAD_HOST_KNOWN_HOSTS }}
          UPLOAD_SUFFIX: ${{ vars.UPLOAD_SUFFIX || 'rspamd.com/dist/' }}
        run: |
          set -euo pipefail
          rsync -e "ssh -l ${{ secrets.SSH_USERNAME }} -i ${KEYFILE} -o UserKnownHostsFile=$HOME/.ssh/known_hosts -o StrictHostKeyChecking=yes" -ru \
            "$GITHUB_WORKSPACE/rpm/rspamd.asc" "${UPLOAD_HOST}:${UPLOAD_SUFFIX}${TARGET_RPM_UNSTABLE}"
          rsync -e "ssh -l ${{ secrets.SSH_USERNAME }} -i ${KEYFILE} -o UserKnownHostsFile=$HOME/.ssh/known_hosts -o StrictHostKeyChecking=yes" -ru \
            "$GITHUB_WORKSPACE/rpm/rspamd.asc" "${UPLOAD_HOST}:${UPLOAD_SUFFIX}${TARGET_RPM_STABLE}"
